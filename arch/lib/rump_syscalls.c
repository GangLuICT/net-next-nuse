/*
 * System call vector and marshalling for rump.
 * DO NOT EDIT-- this file is automatically generated.
 */


#ifdef RUMP_CLIENT
#include <rump/rumpuser_port.h>
#endif /* RUMP_CLIENT */

#include <stdint.h>
#include <string.h>
#include <linux/types.h>
#include <sys/stat.h>
#ifndef __USE_GNU
#define __USE_GNU
#endif /* __USE_GNU */
#include <errno.h>

/* XXX: FIXME to use generated syscalls_64.h */
//#include <asm/syscalls_64.h>
#include <asm/unistd_64.h>

struct pollfd;
struct epoll_event;
struct msghdr;
struct mmsghdr;
struct user_msghdr;
struct iovec;
struct sockaddr;
struct timeval;


/* For hijack.c compatibility of NetBSD */
#define NOT_IMPLEMENTED(x) void (x)(void){}

NOT_IMPLEMENTED(rump___sysimpl_shutdown)
NOT_IMPLEMENTED(rump___sysimpl_readv)
NOT_IMPLEMENTED(rump___sysimpl_pread)
NOT_IMPLEMENTED(rump___sysimpl_preadv)
NOT_IMPLEMENTED(rump___sysimpl_dup2)
NOT_IMPLEMENTED(rump___sysimpl_pollts50)
NOT_IMPLEMENTED(rump___sysimpl_chmod)
NOT_IMPLEMENTED(rump___sysimpl_lchmod)
NOT_IMPLEMENTED(rump___sysimpl_fchmod)
NOT_IMPLEMENTED(rump___sysimpl_chown)
NOT_IMPLEMENTED(rump___sysimpl_lchown)
NOT_IMPLEMENTED(rump___sysimpl_fchown)
NOT_IMPLEMENTED(rump___sysimpl_open)
NOT_IMPLEMENTED(rump___sysimpl_chdir)
NOT_IMPLEMENTED(rump___sysimpl_fchdir)
NOT_IMPLEMENTED(rump___sysimpl_lseek)
NOT_IMPLEMENTED(rump___sysimpl_unlink)
NOT_IMPLEMENTED(rump___sysimpl_symlink)
NOT_IMPLEMENTED(rump___sysimpl_readlink)
NOT_IMPLEMENTED(rump___sysimpl_link)
NOT_IMPLEMENTED(rump___sysimpl_rename)
NOT_IMPLEMENTED(rump___sysimpl_mkdir)
NOT_IMPLEMENTED(rump___sysimpl_rmdir)
NOT_IMPLEMENTED(rump___sysimpl_utimes50)
NOT_IMPLEMENTED(rump___sysimpl_lutimes50)
NOT_IMPLEMENTED(rump___sysimpl_futimes50)
NOT_IMPLEMENTED(rump___sysimpl_utimensat)
NOT_IMPLEMENTED(rump___sysimpl_futimens)
NOT_IMPLEMENTED(rump___sysimpl_truncate)
NOT_IMPLEMENTED(rump___sysimpl_ftruncate)
NOT_IMPLEMENTED(rump___sysimpl_fsync)
NOT_IMPLEMENTED(rump___sysimpl_access)


#ifdef RUMP_CLIENT
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <srcsys/syscall.h>
#include <srcsys/syscallargs.h>

#include <rump/rumpclient.h>

struct syscall_args {
	unsigned long args[6];
};

#define rsys_syscall(num, data, dlen, retval)	    rumpclient_syscall(num, data, dlen, retval)
#define rsys_seterrno(error) errno = error

#else /* !RUMP_CLIENT */

#ifndef __dead
#define __dead __attribute__((__noreturn__))
#endif

#ifndef __printflike
#ifdef __GNUC__
#define __printflike(a,b) __attribute__((__format__ (__printf__,a,b)))
#else
#define __printflike(a,b)
#endif
#endif

#ifndef loff_t
typedef long long      loff_t;
#endif /* loff_t */
typedef int            clockid_t;
typedef unsigned long          u_long;
typedef unsigned int           u_int;
#define RUMP_REGISTER_T long
typedef RUMP_REGISTER_T register_t;
typedef int            pid_t;
typedef struct {
       unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} fd_set;


#include <generated/rump_syscalls.h>
#include <rump/rump.h>
#include <rump/rumpuser.h>
int rump_syscall(int num, void *data, size_t dlen, register_t *retval);
#define rsys_syscall(num, data, dlen, retval)	    rump_syscall(num, data, dlen, retval)

#define rsys_seterrno(error) rumpuser_seterrno(error)

#endif

/* XXX */
#define __user

#define __weak_alias(aliasname, name)						extern __typeof (name) aliasname __attribute__ ((weak, alias (# name)))
//#define __strong_alias(aliasname, name)						extern __typeof (name) aliasname __attribute__ ((strong, alias (# name)))
#define __strong_alias(aliasname, name)

long rump___sysimpl_read(unsigned int fd, char __user * buf, size_t count);
long
rump___sysimpl_read(unsigned int fd,  char __user * buf,  size_t count)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)buf;
	callarg.args[2] = (unsigned long)count;
	error = rsys_syscall(__NR_read, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(read,rump___sysimpl_read);
__weak_alias(_read,rump___sysimpl_read);
__strong_alias(_sys_read,rump___sysimpl_read);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_write(unsigned int fd, const char __user * buf, size_t count);
long
rump___sysimpl_write(unsigned int fd,  const char __user * buf,  size_t count)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)buf;
	callarg.args[2] = (unsigned long)count;
	error = rsys_syscall(__NR_write, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(write,rump___sysimpl_write);
__weak_alias(_write,rump___sysimpl_write);
__strong_alias(_sys_write,rump___sysimpl_write);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_close(unsigned int fd);
long
rump___sysimpl_close(unsigned int fd)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	error = rsys_syscall(__NR_close, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(close,rump___sysimpl_close);
__weak_alias(_close,rump___sysimpl_close);
__strong_alias(_sys_close,rump___sysimpl_close);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_poll(struct pollfd __user * ufds, unsigned int nfds, int timeout);
long
rump___sysimpl_poll(struct pollfd __user * ufds,  unsigned int nfds,  int timeout)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)ufds;
	callarg.args[1] = (unsigned long)nfds;
	callarg.args[2] = (unsigned long)timeout;
	error = rsys_syscall(__NR_poll, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(poll,rump___sysimpl_poll);
__weak_alias(_poll,rump___sysimpl_poll);
__strong_alias(_sys_poll,rump___sysimpl_poll);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
long
rump___sysimpl_ioctl(unsigned int fd,  unsigned int cmd,  unsigned long arg)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)cmd;
	callarg.args[2] = (unsigned long)arg;
	error = rsys_syscall(__NR_ioctl, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(ioctl,rump___sysimpl_ioctl);
__weak_alias(_ioctl,rump___sysimpl_ioctl);
__strong_alias(_sys_ioctl,rump___sysimpl_ioctl);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_pwrite64(unsigned int fd, const char __user * buf, size_t count, loff_t pos);
long
rump___sysimpl_pwrite64(unsigned int fd,  const char __user * buf,  size_t count,  loff_t pos)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)buf;
	callarg.args[2] = (unsigned long)count;
	callarg.args[3] = (unsigned long)pos;
	error = rsys_syscall(__NR_pwrite64, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(pwrite64,rump___sysimpl_pwrite64);
__weak_alias(_pwrite64,rump___sysimpl_pwrite64);
__strong_alias(_sys_pwrite64,rump___sysimpl_pwrite64);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_writev(unsigned long fd, const struct iovec __user * vec, unsigned long vlen);
long
rump___sysimpl_writev(unsigned long fd,  const struct iovec __user * vec,  unsigned long vlen)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)vec;
	callarg.args[2] = (unsigned long)vlen;
	error = rsys_syscall(__NR_writev, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(writev,rump___sysimpl_writev);
__weak_alias(_writev,rump___sysimpl_writev);
__strong_alias(_sys_writev,rump___sysimpl_writev);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_pipe(int __user * fildes);
long
rump___sysimpl_pipe(int __user * fildes)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fildes;
	error = rsys_syscall(__NR_pipe, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(pipe,rump___sysimpl_pipe);
__weak_alias(_pipe,rump___sysimpl_pipe);
__strong_alias(_sys_pipe,rump___sysimpl_pipe);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_select(int n, fd_set __user * inp, fd_set __user * outp, fd_set __user * exp, struct timeval __user * tvp);
long
rump___sysimpl_select(int n,  fd_set __user * inp,  fd_set __user * outp,  fd_set __user * exp,  struct timeval __user * tvp)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)n;
	callarg.args[1] = (unsigned long)inp;
	callarg.args[2] = (unsigned long)outp;
	callarg.args[3] = (unsigned long)exp;
	callarg.args[4] = (unsigned long)tvp;
	error = rsys_syscall(__NR_select, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(select,rump___sysimpl_select);
__weak_alias(_select,rump___sysimpl_select);
__strong_alias(_sys_select,rump___sysimpl_select);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_socket(int, int, int);
long
rump___sysimpl_socket(int arg1, int arg2, int arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_socket, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(socket,rump___sysimpl_socket);
__weak_alias(_socket,rump___sysimpl_socket);
__strong_alias(_sys_socket,rump___sysimpl_socket);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_connect(int, struct sockaddr __user *, int);
long
rump___sysimpl_connect(int arg1,  struct sockaddr __user * arg2, int arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_connect, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(connect,rump___sysimpl_connect);
__weak_alias(_connect,rump___sysimpl_connect);
__strong_alias(_sys_connect,rump___sysimpl_connect);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_accept(int, struct sockaddr __user *, int __user *);
long
rump___sysimpl_accept(int arg1,  struct sockaddr __user * arg2,  int __user * arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_accept, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(accept,rump___sysimpl_accept);
__weak_alias(_accept,rump___sysimpl_accept);
__strong_alias(_sys_accept,rump___sysimpl_accept);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_sendto(int, void __user *, size_t, unsigned,                           struct sockaddr __user *, int);
long
rump___sysimpl_sendto(int arg1,  void __user * arg2, size_t arg3, unsigned arg4,                            struct sockaddr __user * arg5, int arg6)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	callarg.args[3] = (unsigned long)arg4;
	callarg.args[4] = (unsigned long)arg5;
	callarg.args[5] = (unsigned long)arg6;
	error = rsys_syscall(__NR_sendto, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(sendto,rump___sysimpl_sendto);
__weak_alias(_sendto,rump___sysimpl_sendto);
__strong_alias(_sys_sendto,rump___sysimpl_sendto);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_recvfrom(int, void __user *, size_t, unsigned,                             struct sockaddr __user *, int __user *);
long
rump___sysimpl_recvfrom(int arg1,  void __user * arg2, size_t arg3, unsigned arg4,                              struct sockaddr __user * arg5,  int __user * arg6)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	callarg.args[3] = (unsigned long)arg4;
	callarg.args[4] = (unsigned long)arg5;
	callarg.args[5] = (unsigned long)arg6;
	error = rsys_syscall(__NR_recvfrom, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(recvfrom,rump___sysimpl_recvfrom);
__weak_alias(_recvfrom,rump___sysimpl_recvfrom);
__strong_alias(_sys_recvfrom,rump___sysimpl_recvfrom);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_sendmsg(int fd, struct user_msghdr __user * msg, unsigned flags);
long
rump___sysimpl_sendmsg(int fd,  struct user_msghdr __user * msg,  unsigned flags)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)msg;
	callarg.args[2] = (unsigned long)flags;
	error = rsys_syscall(__NR_sendmsg, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(sendmsg,rump___sysimpl_sendmsg);
__weak_alias(_sendmsg,rump___sysimpl_sendmsg);
__strong_alias(_sys_sendmsg,rump___sysimpl_sendmsg);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_recvmsg(int fd, struct user_msghdr __user * msg, unsigned flags);
long
rump___sysimpl_recvmsg(int fd,  struct user_msghdr __user * msg,  unsigned flags)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)msg;
	callarg.args[2] = (unsigned long)flags;
	error = rsys_syscall(__NR_recvmsg, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(recvmsg,rump___sysimpl_recvmsg);
__weak_alias(_recvmsg,rump___sysimpl_recvmsg);
__strong_alias(_sys_recvmsg,rump___sysimpl_recvmsg);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_bind(int, struct sockaddr __user *, int);
long
rump___sysimpl_bind(int arg1,  struct sockaddr __user * arg2, int arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_bind, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(bind,rump___sysimpl_bind);
__weak_alias(_bind,rump___sysimpl_bind);
__strong_alias(_sys_bind,rump___sysimpl_bind);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_listen(int, int);
long
rump___sysimpl_listen(int arg1, int arg2)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	error = rsys_syscall(__NR_listen, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(listen,rump___sysimpl_listen);
__weak_alias(_listen,rump___sysimpl_listen);
__strong_alias(_sys_listen,rump___sysimpl_listen);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_getsockname(int, struct sockaddr __user *, int __user *);
long
rump___sysimpl_getsockname(int arg1,  struct sockaddr __user * arg2,  int __user * arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_getsockname, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(getsockname,rump___sysimpl_getsockname);
__weak_alias(_getsockname,rump___sysimpl_getsockname);
__strong_alias(_sys_getsockname,rump___sysimpl_getsockname);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_getpeername(int, struct sockaddr __user *, int __user *);
long
rump___sysimpl_getpeername(int arg1,  struct sockaddr __user * arg2,  int __user * arg3)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)arg1;
	callarg.args[1] = (unsigned long)arg2;
	callarg.args[2] = (unsigned long)arg3;
	error = rsys_syscall(__NR_getpeername, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(getpeername,rump___sysimpl_getpeername);
__weak_alias(_getpeername,rump___sysimpl_getpeername);
__strong_alias(_sys_getpeername,rump___sysimpl_getpeername);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_setsockopt(int fd, int level, int optname, char __user * optval, int optlen);
long
rump___sysimpl_setsockopt(int fd,  int level,  int optname,  char __user * optval,  int optlen)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)level;
	callarg.args[2] = (unsigned long)optname;
	callarg.args[3] = (unsigned long)optval;
	callarg.args[4] = (unsigned long)optlen;
	error = rsys_syscall(__NR_setsockopt, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(setsockopt,rump___sysimpl_setsockopt);
__weak_alias(_setsockopt,rump___sysimpl_setsockopt);
__strong_alias(_sys_setsockopt,rump___sysimpl_setsockopt);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_getsockopt(int fd, int level, int optname, char __user * optval, int __user * optlen);
long
rump___sysimpl_getsockopt(int fd,  int level,  int optname,  char __user * optval,  int __user * optlen)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)level;
	callarg.args[2] = (unsigned long)optname;
	callarg.args[3] = (unsigned long)optval;
	callarg.args[4] = (unsigned long)optlen;
	error = rsys_syscall(__NR_getsockopt, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(getsockopt,rump___sysimpl_getsockopt);
__weak_alias(_getsockopt,rump___sysimpl_getsockopt);
__strong_alias(_sys_getsockopt,rump___sysimpl_getsockopt);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
long
rump___sysimpl_fcntl(unsigned int fd,  unsigned int cmd,  unsigned long arg)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)cmd;
	callarg.args[2] = (unsigned long)arg;
	error = rsys_syscall(__NR_fcntl, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(fcntl,rump___sysimpl_fcntl);
__weak_alias(_fcntl,rump___sysimpl_fcntl);
__strong_alias(_sys_fcntl,rump___sysimpl_fcntl);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_epoll_create(int size);
long
rump___sysimpl_epoll_create(int size)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)size;
	error = rsys_syscall(__NR_epoll_create, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(epoll_create,rump___sysimpl_epoll_create);
__weak_alias(_epoll_create,rump___sysimpl_epoll_create);
__strong_alias(_sys_epoll_create,rump___sysimpl_epoll_create);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_clock_gettime(clockid_t which_clock, struct timespec __user * tp);
long
rump___sysimpl_clock_gettime(clockid_t which_clock,  struct timespec __user * tp)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)which_clock;
	callarg.args[1] = (unsigned long)tp;
	error = rsys_syscall(__NR_clock_gettime, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(clock_gettime,rump___sysimpl_clock_gettime);
__weak_alias(_clock_gettime,rump___sysimpl_clock_gettime);
__strong_alias(_sys_clock_gettime,rump___sysimpl_clock_gettime);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_epoll_wait(int epfd, struct epoll_event __user * events, int maxevents, int timeout);
long
rump___sysimpl_epoll_wait(int epfd,  struct epoll_event __user * events,  int maxevents,  int timeout)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)epfd;
	callarg.args[1] = (unsigned long)events;
	callarg.args[2] = (unsigned long)maxevents;
	callarg.args[3] = (unsigned long)timeout;
	error = rsys_syscall(__NR_epoll_wait, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(epoll_wait,rump___sysimpl_epoll_wait);
__weak_alias(_epoll_wait,rump___sysimpl_epoll_wait);
__strong_alias(_sys_epoll_wait,rump___sysimpl_epoll_wait);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user * event);
long
rump___sysimpl_epoll_ctl(int epfd,  int op,  int fd,  struct epoll_event __user * event)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)epfd;
	callarg.args[1] = (unsigned long)op;
	callarg.args[2] = (unsigned long)fd;
	callarg.args[3] = (unsigned long)event;
	error = rsys_syscall(__NR_epoll_ctl, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(epoll_ctl,rump___sysimpl_epoll_ctl);
__weak_alias(_epoll_ctl,rump___sysimpl_epoll_ctl);
__strong_alias(_sys_epoll_ctl,rump___sysimpl_epoll_ctl);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_pwritev(unsigned long fd, const struct iovec __user * vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
long
rump___sysimpl_pwritev(unsigned long fd,  const struct iovec __user * vec,  unsigned long vlen,  unsigned long pos_l,  unsigned long pos_h)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)vec;
	callarg.args[2] = (unsigned long)vlen;
	callarg.args[3] = (unsigned long)pos_l;
	callarg.args[4] = (unsigned long)pos_h;
	error = rsys_syscall(__NR_pwritev, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(pwritev,rump___sysimpl_pwritev);
__weak_alias(_pwritev,rump___sysimpl_pwritev);
__strong_alias(_sys_pwritev,rump___sysimpl_pwritev);
#endif /* RUMP_KERNEL_IS_LIBC */

long rump___sysimpl_sendmmsg(int fd, struct mmsghdr __user * msg, unsigned int vlen, unsigned flags);
long
rump___sysimpl_sendmmsg(int fd,  struct mmsghdr __user * msg,  unsigned int vlen,  unsigned flags)
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
	callarg.args[0] = (unsigned long)fd;
	callarg.args[1] = (unsigned long)msg;
	callarg.args[2] = (unsigned long)vlen;
	callarg.args[3] = (unsigned long)flags;
	error = rsys_syscall(__NR_sendmmsg, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(sendmmsg,rump___sysimpl_sendmmsg);
__weak_alias(_sendmmsg,rump___sysimpl_sendmmsg);
__strong_alias(_sys_sendmmsg,rump___sysimpl_sendmmsg);
#endif /* RUMP_KERNEL_IS_LIBC */


__weak_alias(rump___sysimpl_socket30,rump___sysimpl_socket);
__weak_alias(rump___sysimpl_pwrite,rump___sysimpl_pwrite64);

