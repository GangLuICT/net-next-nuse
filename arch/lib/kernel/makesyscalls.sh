#!/bin/sh

in="$1"
out="$2"
out_h="$3"
proto_h="$4"
unistd_h="$5"

# XXX:
SYSCALL_LIST="socket|bind|close|ioctl|connect|recvmsg|recvfrom|sendmsg|getsockname|getpeername|setsockopt|getsockopt|sendmmsg|sendto|fcntl|write|writev|read|listen|accept|epoll_create|epoll_ctl|epoll_wait|pipe|poll|select|pwrite64|pwritev|clock_gettime|getpid|open|nanosleep|reboot"
NR_syscall_max=0

cat <<EOF > ${out_h}
/*
 * System call vector from .master file for rump.
 * DO NOT EDIT-- this file is automatically generated.
 */

EOF

cat <<EOF > ${proto_h}
/*
 * System call prototypes for rump.
 * DO NOT EDIT-- this file is automatically generated.
 */



struct pollfd;
struct epoll_event;
struct msghdr;
struct mmsghdr;
struct iovec;
struct sockaddr;
struct timeval;
struct timespec;

/* XXX */
#define __user
#define user_msghdr msghdr

typedef void (*sys_call_ptr_t)(void);
extern const sys_call_ptr_t rump_sys_call_table[];

struct syscall_args {
	unsigned long args[6];
};

#ifndef umode_t
typedef unsigned short		umode_t;
#endif /* umode_t */

EOF


cat <<EOF > ${unistd_h}

/*
 * This file contains the system call numbers.
 */

EOF

cat <<EOF > ${out}
/*
 * System call vector and marshalling for rump.
 * DO NOT EDIT-- this file is automatically generated.
 */


#ifdef RUMP_CLIENT
#include <rump/rumpuser_port.h>
#endif /* RUMP_CLIENT */

/* XXX: FIXME to use generated syscalls_64.h */
//#include <asm/syscalls_64.h>
#include <asm/unistd_64.h>

struct pollfd;
struct epoll_event;
struct msghdr;
struct mmsghdr;
struct user_msghdr;
struct iovec;
struct sockaddr;
struct timeval;
struct timespec;


#ifdef RUMP_CLIENT
#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <rump/rumpclient.h>

struct syscall_args {
	unsigned long args[6];
};

#ifndef umode_t
typedef unsigned short		umode_t;
#endif /* umode_t */

#define rsys_syscall(num, data, dlen, retval)	\
    rumpclient_syscall(num, data, dlen, retval)
#define rsys_seterrno(error) errno = error

#else /* !RUMP_CLIENT */

#include <linux/compiler.h>
#include <linux/types.h>
#include <linux/string.h>
#include <asm-generic/errno.h>

#ifndef __dead
#define __dead __attribute__((__noreturn__))
#endif

#ifndef __printflike
#ifdef __GNUC__
#define __printflike(a,b) __attribute__((__format__ (__printf__,a,b)))
#else
#define __printflike(a,b)
#endif
#endif

#ifndef loff_t
typedef long long      loff_t;
#endif /* loff_t */
typedef int            clockid_t;
typedef unsigned long          u_long;
typedef unsigned int           u_int;
#define RUMP_REGISTER_T long
typedef RUMP_REGISTER_T register_t;
typedef int            pid_t;


#include <generated/rump_syscalls.h>
#include <rump/rump.h>
#include <rump/rumpuser.h>
int rump_syscall(int num, void *data, size_t dlen, register_t *retval);
#define rsys_syscall(num, data, dlen, retval)	\
    rump_syscall(num, data, dlen, retval)

#define rsys_seterrno(error) rumpuser_seterrno(error)

#endif

/* XXX */
#define __user

#define __weak_alias(aliasname, name)					\
	extern __typeof (name) aliasname __attribute__ ((weak, alias (# name)))
//#define __strong_alias(aliasname, name)					\
	extern __typeof (name) aliasname __attribute__ ((strong, alias (# name)))
#define __strong_alias(aliasname, name)

#define NOT_IMPLEMENTED(x) int (x)(void){      \
	rsys_seterrno(ENOSYS);                 \
	return -1;                             \
        }

NOT_IMPLEMENTED(rump___sysimpl_pollts50)
NOT_IMPLEMENTED(rump___sysimpl_lchmod)
NOT_IMPLEMENTED(rump___sysimpl_lutimes50)
NOT_IMPLEMENTED(rump___sysimpl_futimes50)
NOT_IMPLEMENTED(rump___sysimpl_futimens)

EOF

grep '^[0-9]' "$in" | sort -n | (
    while read nr abi name entry compat; do
	abi=`echo "$abi" | tr '[a-z]' '[A-Z]'`
	NR_syscall_max=${nr}
	# skip compat
	if [ -n "`echo ${entry}|grep compat`" ] ; then
	    continue
	fi

	# skip x32
	if [ -n "`echo ${entry}|grep x32`" ] ; then
	    continue
	fi

	# parse only defined in $(SYSCALL_LIST)
	if [ -z "`echo ${name} | grep -w -E ${SYSCALL_LIST}`" ] ; then
	    #echo "skip=="
	    echo "NOT_IMPLEMENTED(rump___sysimpl_"${name}")"
	    echo ""
	    continue
	fi

	#PROTO=`cpp  include/linux/syscalls.h -I include -I arch/lib/include/generated -I arch/lib/include -I include/uapi -I arch/x86/include -I include |& grep " sys_${name}(" | sed "s/^ //" `
	PROTO=`uncrustify -q -f include/linux/syscalls.h -c arch/lib/kernel/uncrustify-syscalls.cfg | perl -pe 's/,\n/,/g'|& grep " sys_${name}(" | sed "s/^.*asmlinkage //"`
	#echo "${PROTO}"
	RET=`echo "${PROTO}" | cut -d' ' -f1`
	ARGS=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/"`
	ARG[1]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -d',' -f1`
	ARG[2]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -s -d',' -f2`
	ARG[3]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -s -d',' -f3`
	ARG[4]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -s -d',' -f4`
	ARG[5]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -s -d',' -f5`
	ARG[6]=`echo "${PROTO}" | sed "s/^.*(\(.*\));/\1/" | cut -s -d',' -f6`
	PARAM[1]=`echo "${ARG[1]}" | awk -F' ' '{print $NF}'`
	PARAM[2]=`echo "${ARG[2]}" | awk -F' ' '{print $NF}'`
	PARAM[3]=`echo "${ARG[3]}" | awk -F' ' '{print $NF}'`
	PARAM[4]=`echo "${ARG[4]}" | awk -F' ' '{print $NF}'`
	PARAM[5]=`echo "${ARG[5]}" | awk -F' ' '{print $NF}'`
	PARAM[6]=`echo "${ARG[6]}" | awk -F' ' '{print $NF}'`

	# case handling for parameter ommission
	FULL_ARGS=""
	for i in {1..6} ; do
	    case ${PARAM[${i}]} in
		"")
		    continue
		    ;;
		"void")
		    continue
		    ;;
		"int")
		    ARG[${i}]="int arg${i}"
		    PARAM[${i}]="arg${i}"
		    ;;
		"size_t")
		    ARG[${i}]="size_t arg${i}"
		    PARAM[${i}]="arg${i}"
		    ;;
		"unsigned")
		    ARG[${i}]="unsigned arg${i}"
		    PARAM[${i}]="arg${i}"
		    ;;
		'*')
		    ARG[${i}]=${ARG[${i}]}" arg${i}"
		    PARAM[${i}]="arg${i}"
		    ;;
	    esac
	    if [ ${i} -ne 1 ] ; then
		FULL_ARGS=${FULL_ARGS}", "
	    fi
	    FULL_ARGS=${FULL_ARGS}"${ARG[$i]}"
	done

	# not implemented yet
	if [ -n "$compat" ]; then
	    echo "__SYSCALL_${abi}($nr, $entry, $compat)" >> "$out_h"
	elif [ -n "$entry" ]; then
	    echo "__SYSCALL_${abi}($nr, $entry, $entry)" >> "$out_h"
	fi

	echo "$RET rump___sysimpl_${name}(${ARGS});" >> "${proto_h}"
	echo "$RET rump_sys_${name}(${ARGS}) __asm(\"rump___sysimpl_${name}\");" >> "${proto_h}"

	cat <<EOF
$RET rump___sysimpl_${name}(${ARGS});
$RET
rump___sysimpl_${name}(${FULL_ARGS})
{
	register_t retval[2];
	int error = 0;
	struct syscall_args callarg;

	memset(&callarg, 0, sizeof(callarg));
EOF
	idx=-1
	for arg in ${PARAM[1]} ${PARAM[2]} ${PARAM[3]} ${PARAM[4]} ${PARAM[5]} ${PARAM[6]} ; do
	    idx=`expr $idx + 1`
	    if [ -z ${arg} ] ; then
		continue
	    elif [ ${arg} == "void" ] ; then
		continue
	    fi
	    cat <<EOF
	callarg.args[${idx}] = (unsigned long)${arg};
EOF
	done

	cat <<EOF >> "$unistd_h"
#define __NR_${name}                     ${nr}
EOF

	cat <<EOF
	error = rsys_syscall(__NR_${name}, &callarg, sizeof(callarg), retval);
	if (error < 0)
		rsys_seterrno(retval[0]);
	return error;
}
#ifdef RUMP_KERNEL_IS_LIBC
__weak_alias(${name},rump___sysimpl_${name});
__weak_alias(_${name},rump___sysimpl_${name});
__strong_alias(_sys_${name},rump___sysimpl_${name});
#endif /* RUMP_KERNEL_IS_LIBC */

EOF
    done

cat <<EOF

/* For hijack.c compatibility of NetBSD */
__weak_alias(rump___sysimpl_socket30,rump___sysimpl_socket);
__weak_alias(rump___sysimpl_pwrite,rump___sysimpl_pwrite64);
__weak_alias(rump___sysimpl_pread,rump___sysimpl_pread64);
__weak_alias(rump___sysimpl_utimes50,rump___sysimpl_utimes);
__weak_alias(rump___sysimpl_nanosleep50,rump___sysimpl_nanosleep);

EOF

    cat << EOF >> "$out_h"
#define __NR_syscall_max ${NR_syscall_max}
#define NR_syscalls (__NR_syscall_max + 1)

EOF

) >> "$out"
